<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="小彭老师">
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>应知应会 C++ 小技巧 - ✝️小彭大典✝️</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../css/print-site-enum-headings1.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings2.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings3.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings4.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings5.css" rel="stylesheet">
        <link href="../css/print-site-enum-headings6.css" rel="stylesheet">
        <link href="../css/print-site.css" rel="stylesheet">
        <link href="../css/print-site-mkdocs.css" rel="stylesheet">
        <link href="../extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cmake.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/diff.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/java.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/llvm.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/nasm.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/txt.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">✝️小彭大典✝️</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">章节列表</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href=".." class="dropdown-item">前言</a>
</li>
                                    
<li>
    <a href="../hello_world/" class="dropdown-item">你好，世界</a>
</li>
                                    
<li>
    <a href="../platform/" class="dropdown-item">开发环境与平台选择</a>
</li>
                                    
<li>
    <a href="../variable_types/" class="dropdown-item">变量与类型 (未完工)</a>
</li>
                                    
<li>
    <a href="../functions/" class="dropdown-item">认识函数 (未完工)</a>
</li>
                                    
<li>
    <a href="../symbols/" class="dropdown-item">重新认识声明与定义（未完工）</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">应知应会 C++ 小技巧</a>
</li>
                                    
<li>
    <a href="../lambda/" class="dropdown-item">函数式编程</a>
</li>
                                    
<li>
    <a href="../type_rich_api/" class="dropdown-item">现代化的 API 设计指南</a>
</li>
                                    
<li>
    <a href="../no_more_new/" class="dropdown-item">现代 C++ 从拒绝 new 开始</a>
</li>
                                    
<li>
    <a href="../stl_map/" class="dropdown-item">STL 精讲：std::map 和他的朋友们</a>
</li>
                                    
<li>
    <a href="../design_overview/" class="dropdown-item">设计模式总览 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_virtual/" class="dropdown-item">让虚函数再次伟大！</a>
</li>
                                    
<li>
    <a href="../design_gamedev/" class="dropdown-item">游戏开发中常用的设计模式</a>
</li>
                                    
<li>
    <a href="../design_functor/" class="dropdown-item">函数式设计模式</a>
</li>
                                    
<li>
    <a href="../design_variant/" class="dropdown-item">静态多态与面向数据编程 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_erasure/" class="dropdown-item">类型擦除神教及其实现 (未完工)</a>
</li>
                                    
<li>
    <a href="../design_concept/" class="dropdown-item">鸭子类型与 C++20 concept (未完工)</a>
</li>
                                    
<li>
    <a href="../error_code/" class="dropdown-item">现代 C++ 错误处理知多少（未完工）</a>
</li>
                                    
<li>
    <a href="../cpp_lifetime/" class="dropdown-item">深入理解析构函数与生命周期</a>
</li>
                                    
<li>
    <a href="../cpp_memory/" class="dropdown-item">真正的 C++ 内存模型！ (未完工)</a>
</li>
                                    
<li>
    <a href="../unicode/" class="dropdown-item">字符编码那些事</a>
</li>
                                    
<li>
    <a href="../threading/" class="dropdown-item">C++ 多线程编程（未完工）</a>
</li>
                                    
<li>
    <a href="../test_and_safe/" class="dropdown-item">测试与安全话题（未完工）</a>
</li>
                                    
<li>
    <a href="../undef/" class="dropdown-item">未定义行为完整列表</a>
</li>
                                    
<li>
    <a href="../llvm_intro/" class="dropdown-item">小彭老师带你学 LLVM</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">关于</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../about/" class="dropdown-item">关于小彭老师</a>
</li>
                                    
<li>
    <a href="../donate/" class="dropdown-item">赞助名单</a>
</li>
                                    
<li>
    <a href="../recommend/" class="dropdown-item">参考资料与项目</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/parallel101/cppguidebook" class="nav-link">GitHub</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://space.bilibili.com/263032155" class="nav-link">Bilibili</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../symbols/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../lambda/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/parallel101/cppguidebook/edit/master/docs/cpp_tricks.md" class="nav-link"><i class="fa-brands fa-github"></i> Edit on GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#c" class="nav-link">应知应会 C++ 小技巧</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">交换两个变量</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#raii" class="nav-link">RAII 地分配一段内存空间</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">别再写构造函数啦！</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_3" class="nav-link">别再写拷贝构造函数啦！</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_4" class="nav-link">提前返回</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lambda" class="nav-link">立即调用的 Lambda</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lambda_1" class="nav-link">Lambda 复用代码</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#inline" class="nav-link">类内静态成员 inline</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_5" class="nav-link">别再 [] 啦！</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#make_pair" class="nav-link">别再 make_pair 啦！</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#insert" class="nav-link">insert 不会替换现有值哦</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#map" class="nav-link">一边遍历 map，一边删除？</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#vector" class="nav-link">高效删除单个 vector 元素</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#vector_1" class="nav-link">批量删除部分 vector 元素</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#vector_2" class="nav-link">保持有序的 vector</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#c_1" class="nav-link">C++ 随机数的正确生成方式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#const" class="nav-link">const 居然应该后置&hellip;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#cout-endl" class="nav-link">cout 不需要 endl</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#cout" class="nav-link">多线程中 cout 出现乱序？</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#map-any" class="nav-link">map + any 外挂属性</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#bind-lambda" class="nav-link">bind 是历史糟粕，应该由 Lambda 表达式取代</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#forward-fwd" class="nav-link">forward 迷惑性地不好用，建议改用 FWD 宏</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#auto" class="nav-link">函数参数也可以 auto</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_6" class="nav-link">智能指针防止大对象移动</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#optional" class="nav-link">optional 实现延迟初始化</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#if-auto-while-auto" class="nav-link">if-auto 与 while-auto</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_7" class="nav-link">检测是否存在指定成员函数</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#bit-field" class="nav-link">位域（bit-field）</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#vector-unordered_map-lru-cache" class="nav-link">vector + unordered_map = LRU cache</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_8" class="nav-link">多线程通信应基于队列，而不是共享全局变量</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#shared_ptr-deleter" class="nav-link">自定义 shared_ptr 的 deleter</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_9" class="nav-link">读取整个文件</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#raii-finally" class="nav-link">RAII 的 finally</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#swap-mutex" class="nav-link">swap 缩小 mutex 区间代价</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lambda-unique_ptr-function" class="nav-link">Lambda 捕获 unique_ptr 导致 function 报错怎么办</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#check_cuda" class="nav-link">CHECK_CUDA 类错误检测宏</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_10" class="nav-link">函数默认参数求值的位置是调用者</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#locale-utf8" class="nav-link">设置 locale 为 .utf8</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_11" class="nav-link">花括号实现安全的类型转换检查</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#this" class="nav-link">成员函数针对 this 的移动重载</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#bit-field_1" class="nav-link">位域（bit-field）</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#vector-unordered_map-lru-cache_1" class="nav-link">vector + unordered_map = LRU cache</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_12" class="nav-link">多线程通信应基于队列，而不是共享全局变量</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#shared_ptr-deleter_1" class="nav-link">自定义 shared_ptr 的 deleter</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_13" class="nav-link">读取整个文件到字符串</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#raii-finally_1" class="nav-link">RAII 的 finally</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#swap-mutex_1" class="nav-link">swap 缩小 mutex 区间代价</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lambda-unique_ptr-function_1" class="nav-link">Lambda 捕获 unique_ptr 导致 function 报错怎么办</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#check_cuda_1" class="nav-link">CHECK_CUDA 类错误检测宏</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_14" class="nav-link">函数默认参数求值的位置是调用者</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#locale-utf8_1" class="nav-link">设置 locale 为 .utf8</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_15" class="nav-link">花括号实现安全的类型转换检查</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#this_1" class="nav-link">成员函数针对 this 的移动重载</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_16" class="nav-link">临时右值转左值</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_17" class="nav-link">临时变量的生命周期是一行</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="c">应知应会 C++ 小技巧</h1>
<div class="toc">
<ul>
<li><a href="#c">应知应会 C++ 小技巧</a><ul>
<li><a href="#_1">交换两个变量</a></li>
<li><a href="#raii">RAII 地分配一段内存空间</a></li>
<li><a href="#_2">别再写构造函数啦！</a></li>
<li><a href="#_3">别再写拷贝构造函数啦！</a></li>
<li><a href="#_4">提前返回</a></li>
<li><a href="#lambda">立即调用的 Lambda</a></li>
<li><a href="#lambda_1">Lambda 复用代码</a></li>
<li><a href="#inline">类内静态成员 inline</a></li>
<li><a href="#_5">别再 [] 啦！</a></li>
<li><a href="#make_pair">别再 make_pair 啦！</a></li>
<li><a href="#insert">insert 不会替换现有值哦</a></li>
<li><a href="#map">一边遍历 map，一边删除？</a></li>
<li><a href="#vector">高效删除单个 vector 元素</a></li>
<li><a href="#vector_1">批量删除部分 vector 元素</a></li>
<li><a href="#vector_2">保持有序的 vector</a></li>
<li><a href="#c_1">C++ 随机数的正确生成方式</a></li>
<li><a href="#const">const 居然应该后置&hellip;</a></li>
<li><a href="#cout-endl">cout 不需要 endl</a></li>
<li><a href="#cout">多线程中 cout 出现乱序？</a></li>
<li><a href="#map-any">map + any 外挂属性</a></li>
<li><a href="#bind-lambda">bind 是历史糟粕，应该由 Lambda 表达式取代</a></li>
<li><a href="#forward-fwd">forward 迷惑性地不好用，建议改用 FWD 宏</a></li>
<li><a href="#auto">函数参数也可以 auto</a></li>
<li><a href="#_6">智能指针防止大对象移动</a></li>
<li><a href="#optional">optional 实现延迟初始化</a></li>
<li><a href="#if-auto-while-auto">if-auto 与 while-auto</a></li>
<li><a href="#_7">检测是否存在指定成员函数</a></li>
<li><a href="#bit-field">位域（bit-field）</a></li>
<li><a href="#vector-unordered_map-lru-cache">vector + unordered_map = LRU cache</a></li>
<li><a href="#_8">多线程通信应基于队列，而不是共享全局变量</a></li>
<li><a href="#shared_ptr-deleter">自定义 shared_ptr 的 deleter</a></li>
<li><a href="#_9">读取整个文件</a></li>
<li><a href="#raii-finally">RAII 的 finally</a></li>
<li><a href="#swap-mutex">swap 缩小 mutex 区间代价</a></li>
<li><a href="#lambda-unique_ptr-function">Lambda 捕获 unique_ptr 导致 function 报错怎么办</a></li>
<li><a href="#check_cuda">CHECK_CUDA 类错误检测宏</a></li>
<li><a href="#_10">函数默认参数求值的位置是调用者</a></li>
<li><a href="#locale-utf8">设置 locale 为 .utf8</a></li>
<li><a href="#_11">花括号实现安全的类型转换检查</a></li>
<li><a href="#this">成员函数针对 this 的移动重载</a></li>
<li><a href="#bit-field_1">位域（bit-field）</a></li>
<li><a href="#vector-unordered_map-lru-cache_1">vector + unordered_map = LRU cache</a></li>
<li><a href="#_12">多线程通信应基于队列，而不是共享全局变量</a></li>
<li><a href="#shared_ptr-deleter_1">自定义 shared_ptr 的 deleter</a></li>
<li><a href="#_13">读取整个文件到字符串</a></li>
<li><a href="#raii-finally_1">RAII 的 finally</a></li>
<li><a href="#swap-mutex_1">swap 缩小 mutex 区间代价</a></li>
<li><a href="#lambda-unique_ptr-function_1">Lambda 捕获 unique_ptr 导致 function 报错怎么办</a></li>
<li><a href="#check_cuda_1">CHECK_CUDA 类错误检测宏</a></li>
<li><a href="#_14">函数默认参数求值的位置是调用者</a></li>
<li><a href="#locale-utf8_1">设置 locale 为 .utf8</a></li>
<li><a href="#_15">花括号实现安全的类型转换检查</a></li>
<li><a href="#this_1">成员函数针对 this 的移动重载</a></li>
<li><a href="#_16">临时右值转左值</a></li>
<li><a href="#_17">临时变量的生命周期是一行</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="_1">交换两个变量</h2>
<pre><code class="language-cpp">int a = 42;
int b = 58;
</code></pre>
<p>现在你想交换这两个变量。</p>
<pre><code class="language-cpp">int tmp = a;
a = b;
b = tmp;
</code></pre>
<p>但是标准库提供了更好的方法：</p>
<pre><code class="language-cpp">std::swap(a, b);
</code></pre>
<p>这个方法可以交换任意两个同类型的值，包括结构体、数组、容器等。</p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 只需要 <code>#include &lt;utility&gt;</code> 就可以使用！</p>
</blockquote>
<h2 id="raii">RAII 地分配一段内存空间</h2>
<p>小彭老师：不要让我看到 new 和 delete。</p>
<p>同学：我想要<strong>分配一段内存空间</strong>，你不让我 new，我还能怎么办呢？</p>
<pre><code class="language-cpp">char *mem = new char[1024];   // 同学想要 1024 字节的缓冲区
read(1, mem, 1024);           // 用于供 C 语言的读文件函数使用
delete[] mem;                 // 需要手动 delete
</code></pre>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 可以看到，他所谓的“内存空间”实际上就是一个“char 数组”。</p>
</blockquote>
<p>小彭老师：有没有一种可能，vector 就可以分配内存空间。</p>
<pre><code class="language-cpp">vector&lt;char&gt; mem(1024);
read(1, mem.data(), mem.size());
</code></pre>
<p>vector 一样符合 RAII 思想，构造时自动申请内存，离开作用域时自动释放。</p>
<p>只需在调用 C 语言接口时，取出原始指针：</p>
<ul>
<li>用 data() 即可获取出首个 char 元素的指针，用于传递给 C 语言函数使用。</li>
<li>用 size() 取出数组的长度，即是内存空间的字节数，因为我们的元素类型是 char，char 刚好就是 1 字节的，size() 刚好就是字节的数量。</li>
</ul>
<p>此处 read 函数读完后，数据就直接进入了 vector 中，根本不需要什么 new。</p>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> 更现代的 C++ 思想家还会用 <code>vector&lt;std::byte&gt;</code>，明确区分这是“字节”不是“字符”。如果你读出来的目的是当作字符串，可以用 <code>std::string</code>。</p>
<p><img src="../img/warning.png" height="30px" width="auto" style="margin: 0; border: none"/> 注意：一些愚蠢的教材中，用 <code>shared_ptr</code> 和 <code>unique_ptr</code> 来管理数组，这是错误的。</p>
<p><code>shared_ptr</code> 和 <code>unique_ptr</code> 智能指针主要是用于管理“单个对象”的，不是管理“数组”的。</p>
<p><code>vector</code> 一直都是数组的管理方式，且从 C++98 就有。不要看到 “new 的替代品” 只想到智能指针啊！“new [] 的替代品” 是 <code>vector</code> 啊！</p>
</blockquote>
<p>此处放出一个利用 <code>std::wstring</code> 分配 <code>wchar_t *</code> 内存的案例：</p>
<pre><code class="language-cpp">std::wstring utf8_to_wstring(std::string const &amp;s) {
    int len = MultiByteToWideChar(CP_UTF8, 0,
                                  s.data(), s.size(),
                                  nullptr, 0);  // 先确定长度
    std::wstring ws(len, 0);
    MultiByteToWideChar(CP_UTF8, 0,
                        s.data(), s.size(), 
                        ws.data(), ws.size());  // 再读出数据
    return ws;
}
</code></pre>
<h2 id="_2">别再写构造函数啦！</h2>
<pre><code class="language-cpp">// C++98
struct Student {
    string name;
    int age;
    int id;

    Student(string name_, int age_, int id_) : name(name_), age(age_), id(id_) {}
};

Student stu(&quot;侯捷老师&quot;, 42, 123);
</code></pre>
<p>C++98 需要手动书写构造函数，非常麻烦！而且几乎都是重复的。</p>
<p>C++11 中，平凡的结构体类型不需要再写构造函数了，只需用 <code>{}</code> 就能对成员依次初始化：</p>
<pre><code class="language-cpp">// C++11
struct Student {
    string name;
    int age;
    int id;
};

Student stu{&quot;小彭老师&quot;, 24, 123};
</code></pre>
<p>这被称为<strong>聚合初始化</strong> (aggergate initialize)。只要你的类没有自定义构造函数，没有 private 成员，都可以用 <code>{}</code> 聚合初始化。</p>
<p>好消息：C++20 中，聚合初始化也支持 <code>()</code> 了，用起来就和传统的 C++98 构造函数一样！</p>
<pre><code class="language-cpp">// C++20
Student stu(&quot;小彭老师&quot;, 24, 123);
</code></pre>
<p>聚合初始化还可以指定默认值：</p>
<pre><code class="language-cpp">// C++11
struct Student {
    string name;
    int age;
    int id = 9999;
};

Student stu{&quot;小彭老师&quot;, 24};
// 等价于：
Student stu{&quot;小彭老师&quot;, 24, 9999};
</code></pre>
<p>C++20 开始，<code>{}</code> 聚合初始化还可以根据每个成员的名字来指定值：</p>
<pre><code class="language-cpp">Student stu{.name = &quot;小彭老师&quot;, .age = 24, .id = 9999};
// 等价于：
Student stu{&quot;小彭老师&quot;, 24, 9999};
</code></pre>
<p>好处是，即使不慎写错参数顺序也不用担心。</p>
<pre><code class="language-cpp">Student stu{.name = &quot;小彭老师&quot;, .age = 24, .id = 9999};
Student stu{.name = &quot;小彭老师&quot;, .id = 9999, .age = 24};
</code></pre>
<h2 id="_3">别再写拷贝构造函数啦！</h2>
<p>只有当你需要有“自定义钩子逻辑”的时候，才需要自定义构造函数。</p>
<pre><code class="language-cpp">struct Student {
    string name;
    int age;
    int id;

    Student(string name_, int age_, int id_) : name(name_), age(age_), id(id_) {}

    Student(Student const &amp;other) : name(other.name), age(other.age), id(other.id) {
        std::cout &lt;&lt; &quot;拷贝构造\n&quot;;
    }

    Student &amp;operator=(Student const &amp;other) {
        name = other.name;
        age = other.age;
        id = other.id;
        std::cout &lt;&lt; &quot;拷贝赋值\n&quot;;
        return *this;
    }
};

Student stu1(&quot;侯捷老师&quot;, 42, 123);
Student stu2 = stu1;  // 拷贝构造
stu2 = stu1;          // 拷贝赋值
</code></pre>
<p>如果你不需要这个 <code>std::cout</code>，只是平凡地拷贝所有成员，完全可以不写，让编译器自动生成拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数：</p>
<pre><code class="language-cpp">struct Student {
    string name;
    int age;
    int id;

    Student(string name_, int age_, int id_) : name(name_), age(age_), id(id_) {}

    // 编译器自动生成 Student(Student const &amp;other)
    // 编译器自动生成 Student &amp;operator=(Student const &amp;other)
};

Student stu1(&quot;侯捷老师&quot;, 42, 123);
Student stu2 = stu1;  // 拷贝构造
stu2 = stu1;          // 拷贝赋值
assert(stu2.name == &quot;侯捷老师&quot;);
</code></pre>
<p>总之，很多 C++ 教材把拷贝/移动构造函数过于夸大，搞得好像每个类都需要自己定义一样。</p>
<p>实际上，只有在“自己实现容器”的情况下，才需要自定义拷贝构造函数。可是谁会整天手搓容器？</p>
<p>大多数情况下，我们只需要在类里面存 vector、string 等封装好的容器，编译器默认生成的拷贝构造函数会自动调用他们的拷贝构造函数，用户只需专注于业务逻辑即可，不需要操心底层细节。</p>
<h2 id="_4">提前返回</h2>
<pre><code class="language-cpp">void babysitter(Baby *baby) {
    if (!baby-&gt;is_alive()) {
        puts(&quot;宝宝已经去世了&quot;);
    } else {
        puts(&quot;正在检查宝宝喂食情况...&quot;);
        if (baby-&gt;is_feeded()) {
            puts(&quot;宝宝已经喂食过了&quot;);
        } else {
            puts(&quot;正在喂食宝宝...&quot;);
            puts(&quot;正在调教宝宝...&quot;);
            puts(&quot;正在安抚宝宝...&quot;);
        }
    }
}
</code></pre>
<p>这个函数有很多层嵌套，很不美观。用<strong>提前返回</strong>的写法来优化：</p>
<pre><code class="language-cpp">void babysitter(Baby *baby) {
    if (!baby-&gt;is_alive()) {
        puts(&quot;宝宝已经去世了&quot;);
        return;
    }
    puts(&quot;正在检查宝宝喂食情况...&quot;);
    if (baby-&gt;is_feeded()) {
        puts(&quot;宝宝已经喂食过了&quot;);
        return;
    }
    puts(&quot;正在喂食宝宝...&quot;);
    puts(&quot;正在调教宝宝...&quot;);
    puts(&quot;正在安抚宝宝...&quot;);
}
</code></pre>
<h2 id="lambda">立即调用的 Lambda</h2>
<p>有时，需要在一个列表里循环查找某样东西，也可以用提前返回的写法优化：</p>
<pre><code class="language-cpp">bool find(const vector&lt;int&gt; &amp;v, int target) {
    for (int i = 0; i &lt; v.size(); ++i) {
        if (v[i] == target) {
            return true;
        }
    }
    return false;
}
</code></pre>
<p>可以包裹一个立即调用的 Lambda 块 <code>[&amp;] { ... } ()</code>，限制提前返回的范围：</p>
<pre><code class="language-cpp">void find(const vector&lt;int&gt; &amp;v, int target) {
    bool found = [&amp;] {
        for (int i = 0; i &lt; v.size(); ++i) {
            if (v[i] == target) {
                return true;
            }
        }
        return false;
    } ();
    if (found) {
        ...
    }
}
</code></pre>
<h2 id="lambda_1">Lambda 复用代码</h2>
<pre><code class="language-cpp">vector&lt;string&gt; spilt(string str) {
    vector&lt;string&gt; list;
    string last;
    for (char c: str) {
        if (c == ' ') {
            list.push_back(last);
            last.clear();
        } else {
            last.push_back(c);
        }
    }
    list.push_back(last);
    return list;
}
</code></pre>
<p>上面的代码可以用 Lambda 复用：</p>
<pre><code class="language-cpp">vector&lt;string&gt; spilt(string str) {
    vector&lt;string&gt; list;
    string last;
    auto push = [&amp;] {
        list.push_back(last);
        last.clear();
    };
    for (char c: str) {
        if (c == ' ') {
            push();
        } else {
            last.push_back(c);
        }
    }
    push();
    return list;
}
</code></pre>
<h2 id="inline">类内静态成员 inline</h2>
<p>在头文件中定义结构体的 static 成员时：</p>
<pre><code class="language-cpp">struct Class {
    static Class instance;
};
</code></pre>
<p>会报错 <code>undefined reference to 'Class::instance'</code>。这是说的你需要找个 .cpp 文件，写出 <code>Class Class::instance</code> 才能消除该错误。</p>
<p>C++17 中，只需加个 <code>inline</code> 就能解决！</p>
<pre><code class="language-cpp">struct Class {
    inline static Class instance;
};
</code></pre>
<h2 id="_5">别再 <code>[]</code> 啦！</h2>
<p>你知道吗？在 map 中使用 <code>[]</code> 查找元素，如果不存在，会自动创建一个默认值。这个特性有时很方便，但如果你不小心写错了，就会在 map 中创建一个多余的默认元素。</p>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
table[&quot;小彭老师&quot;] = 24;

cout &lt;&lt; table[&quot;侯捷老师&quot;];
</code></pre>
<p>table 中明明没有 &ldquo;侯捷老师&rdquo; 这个元素，但由于 <code>[]</code> 的特性，他会默认返回一个 0，不会爆任何错误！</p>
<p>改用更安全的 <code>at()</code> 函数，当查询的元素不存在时，会抛出异常，方便你调试：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
table.at(&quot;小彭老师&quot;) = 24;

cout &lt;&lt; table.at(&quot;侯捷老师&quot;);  // 抛出异常
</code></pre>
<p><code>[]</code> 真正的用途是“写入新元素”时，如果元素不存在，他可以自动帮你创建一个默认值，供你以引用的方式赋值进去。</p>
<p>检测元素是否存在可以用 <code>count</code>：</p>
<pre><code class="language-cpp">if (table.count(&quot;小彭老师&quot;)) {
    return table.at(&quot;小彭老师&quot;);
} else {
    return 0;
}
</code></pre>
<p>即使你想要默认值 0 这一特性，<code>count</code> + <code>at</code> 也比 <code>[]</code> 更好，因为 <code>[]</code> 的默认值是会对 table 做破坏性修改的，这导致 <code>[]</code> 需要 <code>map</code> 的声明不为 <code>const</code>：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
return table[&quot;小彭老师&quot;]; // 如果&quot;小彭老师&quot;这一键不存在，会创建&quot;小彭老师&quot;并设为默认值 0
</code></pre>
<pre><code class="language-cpp">const map&lt;string, int&gt; table;
return table[&quot;小彭老师&quot;]; // 编译失败！[] 需要非 const 的 map 对象，因为他会破坏性修改
</code></pre>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 更多 map 知识请看我们的 <a href="../stl_map/">map 专题课</a>。</p>
</blockquote>
<h2 id="make_pair">别再 make_pair 啦！</h2>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
table.insert(pair&lt;string, int&gt;(&quot;侯捷老师&quot;, 42));
</code></pre>
<p>为避免写出类型名的麻烦，很多老师都会让你写 make_pair：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
table.insert(make_pair(&quot;侯捷老师&quot;, 42));
</code></pre>
<p>然而 C++11 提供了更好的写法，那就是通过 <code>{}</code> 隐式构造，不用写出类型名或 make_pair：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
table.insert({&quot;侯捷老师&quot;, 42});
</code></pre>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 即使你出于某种“抖m”情节，还想写出类型名，也可以用 C++17 的 CTAD 语法，免去模板参数：</p>
</blockquote>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
table.insert(pair(&quot;侯捷老师&quot;, 42));

// tuple 也支持 CTAD：
auto t = tuple(&quot;侯捷老师&quot;, 42, string(&quot;小彭老师&quot;));
// 等价于：
auto t = make_tuple(&quot;侯捷老师&quot;, 42, string(&quot;小彭老师&quot;));

println(&quot;{}&quot;, typeid(t).name()); // tuple&lt;const char *, int, string&gt;
</code></pre>
<h2 id="insert">insert 不会替换现有值哦</h2>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
table.insert({&quot;小彭老师&quot;, 24});
table.insert({&quot;小彭老师&quot;, 42});
</code></pre>
<p>这时，<code>table["小彭老师"]</code> 仍然会是 24，而不是 42。因为 insert 不会替换 map 里已经存在的值。</p>
<p>如果希望如果已经存在时，替换现有元素，可以使用 <code>[]</code> 运算符：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
table[&quot;小彭老师&quot;] = 24;
table[&quot;小彭老师&quot;] = 42;
</code></pre>
<p>C++17 提供了比 <code>[]</code> 运算符更适合覆盖性插入的 <code>insert_or_assign</code> 函数：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
table.insert_or_assign(&quot;小彭老师&quot;, 24);
table.insert_or_assign(&quot;小彭老师&quot;, 42);
</code></pre>
<p>好处：<code>insert_or_assign</code> 不需要值类型支持默认构造，可以避免一次默认构造函数 + 一次移动赋值函数的开销。</p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 建议把 <code>insert_or_assign</code> 改名成 <code>set</code>，<code>at</code> 改名成 <code>get</code>；只是由于历史原因名字迷惑了。</p>
</blockquote>
<h2 id="map">一边遍历 map，一边删除？</h2>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
for (auto it = table.begin(); it != table.end(); ++it) {
    if (it-&gt;second &lt; 0) {
        table.erase(it);
    }
}
</code></pre>
<p>会发生崩溃！看来 map 似乎不允许在遍历的过程中删除？不，只是你的写法有错误：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
for (auto it = table.begin(); it != table.end(); ) {
    if (it-&gt;second &lt; 0) {
        it = table.erase(it);
    } else {
        ++it;
    }
}
</code></pre>
<p>C++20 引入了更好的 erase_if 全局函数，不用手写上面这么麻烦的代码：</p>
<pre><code class="language-cpp">map&lt;string, int&gt; table;
erase_if(table, [](pair&lt;string, int&gt; it) {
    return it.second &lt; 0;
});
</code></pre>
<h2 id="vector">高效删除单个 vector 元素</h2>
<pre><code class="language-cpp">vector&lt;int&gt; v = {48, 23, 76, 11, 88, 63, 45, 28, 59};
</code></pre>
<p>众所周知，在 vector 中删除元素，会导致后面的所有元素向前移动，十分低效。复杂度：<span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span></p>
<pre><code class="language-cpp">// 直接删除 v[3]
v.erase(v.begin() + 3);
</code></pre>
<p>如果不在乎元素的顺序，可以把要删除的元素和最后一个元素 swap，然后 pop_back。复杂度：<span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span></p>
<pre><code class="language-cpp">// 把 v[3] 和 v[v.size() - 1] 位置对调
swap(v[3], v[v.size() - 1]);
// 然后删除 v[v.size() - 1]
v.pop_back();
</code></pre>
<p>这样就不用移动一大堆元素了。这被称为 back-swap-erase。</p>
<h2 id="vector_1">批量删除部分 vector 元素</h2>
<p>vector 中只删除一个元素需要 <span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>。如果一边遍历，一边删除多个符合条件的元素，就需要复杂度 <span class="arithmatex"><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span> 了。</p>
<p>标准库提供了 <code>remove</code> 和 <code>remove_if</code> 函数，其内部采用类似 back-swap-erase 的方法，先把要删除的元素移动到末尾。然后一次性 <code>erase</code> 掉末尾同样数量的元素。</p>
<p>且他们都能保持顺序不变。</p>
<p>删除所有值为 42 的元素：</p>
<pre><code class="language-cpp">vector&lt;int&gt; v;
v.erase(remove(v.begin(), v.end(), 42), v.end());
</code></pre>
<p>删除所有值大于 0 的元素：</p>
<pre><code class="language-cpp">vector&lt;int&gt; v;
v.erase(remove_if(v.begin(), v.end(), [](int x) {
    return x &gt; 0;
}), v.end());
</code></pre>
<p>现在 C++20 也引入了全局函数 erase 和 erase_if，使用起来更加直观：</p>
<pre><code class="language-cpp">vector&lt;int&gt; v;
erase(v, 42);       // 删除所有值为 42 的元素
erase_if(v, [](int x) {
    return x &gt; 0;   // 删除所有值大于 0 的元素
});
</code></pre>
<h2 id="vector_2">保持有序的 vector</h2>
<p>如果你想要维护一个有序的数组，用 <code>lower_bound</code> 或 <code>upper_bound</code> 来插入元素，保证插入后仍保持有序：</p>
<pre><code class="language-cpp">vector&lt;int&gt; s;
s.push_back(1);
s.push_back(2);
s.push_back(4);
s.push_back(6);
// s = { 1, 2, 4, 6 }
s.insert(lower_bound(s.begin(), s.end(), 3), 3);
// s = { 1, 2, 3, 4, 6 }
s.insert(lower_bound(s.begin(), s.end(), 5), 5);
// s = { 1, 2, 3, 4, 5, 6 }
</code></pre>
<p>有序数组中，可以利用 <code>lower_bound</code> 或 <code>upper_bound</code> 快速二分查找到想要的值：</p>
<pre><code class="language-cpp">vector&lt;int&gt; s;
s.push_back(1);
s.push_back(2);
s.push_back(4);
s.push_back(6);
// s = { 1, 2, 4, 6 }
lower_bound(s.begin(), s.end(), 3); // s.begin() + 2;
lower_bound(s.begin(), s.end(), 5); // s.begin() + 3;
</code></pre>
<p>有序 vector 应用案例：利用 CDF 积分 + 二分法可以实现生成任意指定分布的随机数。</p>
<p>例如抽卡概率要求：</p>
<ul>
<li>2% 出金卡</li>
<li>10% 出蓝卡</li>
<li>80% 出白卡</li>
<li>8% 出答辩</li>
</ul>
<pre><code class="language-cpp">vector&lt;double&gt; probs = {0.02, 0.1, 0.8, 0.08};
vector&lt;double&gt; cdf;
// 计算 probs 的 CDF 积分，存入 cdf 数组
std::partial_sum(probs.begin(), probs.end(), std::back_inserter(cdf));
// cdf = {0.02, 0.12, 0.92, 1.00} 是一个有序 vector，可以运用二分法

vector&lt;string&gt; result = {&quot;金卡&quot;, &quot;蓝卡&quot;, &quot;白卡&quot;, &quot;答辩&quot;};
// 生成 100 个随机数：
for (int i = 0; i &lt; 100; ++i) {
    double r = rand() / (RAND_MAX + 1.);
    int index = lower_bound(cdf.begin(), cdf.end(), r) - cdf.begin();
    cout &lt;&lt; &quot;你抽到了&quot; &lt;&lt; result[index] &lt;&lt; endl;
}
</code></pre>
<h2 id="c_1">C++ 随机数的正确生成方式</h2>
<pre><code class="language-cpp">// 错误的写法：
int r = rand() % 10; // 这样写是错误的！
</code></pre>
<p>rand() 的返回值范围是 [0, RAND_MAX]，RAND_MAX 在不同平台下不同，在 Windows 平台的是 32767，即 rand() 只能生成 0～32767 之间的随机数。</p>
<p>如果想要生成 0～9 之间的随机数，最简单的办法是：</p>
<pre><code class="language-cpp">int r = rand() % 10;
</code></pre>
<p>然而这种方法有个致命的问题：不同的随机数生成概率不一样。</p>
<p>例如把 [0, RAND_MAX] 均匀地分成 10 份，每份 3276.7。那么 0～6 之间的数字出现的概率是 3276.7 / 32767 = 10.0003%，而 7～9 之间的数字出现的概率是 3276.7 / 32767 = 9.997%。</p>
<p>这样就不是真正的均匀分布，这可能会影响程序的正确性。</p>
<ul>
<li>当模数大的时候不均匀性会变得特别明显，例如 <code>rand() % 10000</code>。</li>
<li>RAND_MAX 在不同平台不同的特性也让跨平台开发者很头大。</li>
<li><code>rand</code> 使用全局变量存储种子，对多线程不友好。</li>
<li>无法独立的为多个生成序列设定独立的种子，一些游戏可能需要用到多个随机序列，各自有独立的种子。</li>
<li>只能生成均匀分布的整数，不能生成幂率分布、正太分布等，生成浮点数也比较麻烦。</li>
<li>使用 <code>srand(time(NULL))</code> 无法安全地生成随机数的初始种子，容易被黑客预测并攻击。</li>
<li><code>rand</code> 的算法实现没有官方规定，在不同平台各有不同，产生的随机数序列可能不同。</li>
</ul>
<p>为此，C++ 提出了更加专业的随机数生成器：<code>&lt;random&gt;</code> 库。</p>
<pre><code class="language-cpp">// 使用 &lt;random&gt; 库生成 0～9 之间的随机数：
#include &lt;random&gt;
#include &lt;iostream&gt;

int main() {
    uint64_t seed = std::random_device()();
    std::mt19937 gen(seed);
    std::uniform_int_distribution&lt;int&gt; dis(0, 9);

    for (int i = 0; i &lt; 100; ++i) {
        int r = dis(gen);
        std::cout &lt;&lt; r &lt;&lt; &quot; &quot;;
    }
}
</code></pre>
<p>这样就可以生成 0～9 之间的均匀分布的随机数了。</p>
<ul>
<li><code>std::random_device</code> 是一个随机数种子生成器，它会利用系统的随机设备（如果有的话，否则会抛出异常）生成一个安全的随机数种子，黑客无法预测。</li>
<li><code>std::mt19937</code> 是一个随机数生成器，它会利用初始种子生成一个随机数序列。并且必定是 MT19937 这个高强度的随机算法，所有平台都一样。</li>
<li><code>std::uniform_int_distribution</code> 是一个分布器，它可以把均匀分布的随机数映射到我们想要的上下界中。里面的实现类似于 <code>gen() % 10</code>，但通过数学机制保证了绝对均匀性。</li>
</ul>
<p>类似的还有 <code>std::uniform_real_distribution</code> 用于生成浮点数，<code>std::normal_distribution</code> 用于生成正太分布的随机数，<code>std::poisson_distribution</code> 用于生成泊松分布的随机数，等等。</p>
<p>如果喜欢老式的函数调用风格接口，可以封装一个新的 C++ 重置版安全 <code>rand</code>：</p>
<pre><code class="language-cpp">thread_local std::mt19937 gen(std::random_device()()); // 每线程一个，互不冲突

int randint(int min, int max) {
    return std::uniform_int_distribution&lt;int&gt;(min, max)(gen);
}

float randfloat(float min, float max) {
    return std::uniform_real_distribution&lt;float&gt;(min, max)(gen);
}
</code></pre>
<h2 id="const">const 居然应该后置&hellip;</h2>
<p>众所周知，<code>const</code> 在指针符号 <code>*</code> 的前后，效果是不同的。</p>
<pre><code class="language-cpp">const int *p;
int *const p;
</code></pre>
<p>你能看出来上面这个 const 分别修饰的是谁吗？</p>
<pre><code class="language-cpp">const int *p;  // 指针指向的 int 不可变
int *const p;  // 指针本身不可改变指向
</code></pre>
<p>为了看起来更加明确，我通常都会后置所有的 const 修饰。</p>
<pre><code class="language-cpp">int const *p;  // 指针指向的 int 不可变
int *const p;  // 指针本身不可改变指向
</code></pre>
<p>这样就一目了然，const 总是在修饰他前面的东西，而不是后面。</p>
<p>为什么 <code>int *const</code> 修饰的是 <code>int *</code> 也就很容易理解了。</p>
<pre><code class="language-cpp">int const i;
int const *p;
int *const q;
int const &amp;r;
</code></pre>
<p>举个例子：</p>
<pre><code class="language-cpp">int i, j;
int *const p = &amp;i;
*p = 1;  // OK：p 指向的对象可变
p = &amp;j;  // 错误：p 本身不可变，不能改变指向
</code></pre>
<pre><code class="language-cpp">int i, j;
int const *p = &amp;i;
*p = 1;  // 错误：p 指向的对象不可变
p = &amp;j;  // OK：p 本身可变，可以改变指向
</code></pre>
<pre><code class="language-cpp">int i, j;
int const *const p = &amp;i;
*p = 1;  // 错误：p 指向的对象不可变
p = &amp;j;  // 错误：p 本身也不可变，不能改变指向
</code></pre>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> <code>int const *</code> 和 <code>const int *</code> 等价！只有 <code>int *const</code> 是不同的。</p>
</blockquote>
<h2 id="cout-endl">cout 不需要 endl</h2>
<pre><code class="language-cpp">int a = 42;
printf(&quot;%d\n&quot;, a);
</code></pre>
<p>万一你写错了 <code>%</code> 后面的类型，编译器不会有任何报错，留下隐患。</p>
<pre><code class="language-cpp">int a = 42;
printf(&quot;%s\n&quot;, a);  // 编译器不报错，但是运行时会崩溃！
</code></pre>
<p>C++ 中有更安全的输出方式 <code>cout</code>，通过 C++ 的重载机制，无需手动指定 <code>%</code>，自动就能推导类型。</p>
<pre><code class="language-cpp">int a = 42;
cout &lt;&lt; a &lt;&lt; endl;
double d = 3.14;
cout &lt;&lt; d &lt;&lt; endl;
</code></pre>
<pre><code class="language-cpp">cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;
</code></pre>
<p>endl 是一个特殊的流操作符，作用等价于先输出一个 <code>'\n'</code> 然后 <code>flush</code>。</p>
<pre><code class="language-cpp">cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; '\n';
cout.flush();
</code></pre>
<p>但实际上，输出流 cout 默认的设置就是“行刷新缓存”，也就是说，检测到 <code>'\n'</code> 时，就会自动刷新一次，根本不需要我们手动刷新！</p>
<p>如果还用 endl 的话，就相当于刷新了两次，浪费性能。</p>
<p>所以，我们只需要输出 <code>'\n'</code> 就可以了，每次换行时 cout 都会自动刷新，endl 是一个典型的以讹传讹错误写法。</p>
<pre><code class="language-cpp">cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; '\n';
</code></pre>
<h2 id="cout">多线程中 cout 出现乱序？</h2>
<p>同学：小彭老师，我在多线程环境中使用：</p>
<pre><code class="language-cpp">cout &lt;&lt; &quot;the answer is &quot; &lt;&lt; 42 &lt;&lt; '\n';
</code></pre>
<p>发现输出乱套了！这是不是说明 cout 不是<strong>多线程安全</strong>的呢？</p>
<p>小彭老师：cout 是一个“同步流”，是<strong>多线程安全</strong>的，错误的是你的使用方式。</p>
<blockquote>
<p><img src="../img/book.png" height="30px" width="auto" style="margin: 0; border: none"/> 如果他不多线程安全，那多线程地调用他就不是输出乱序，而是程序崩溃了。</p>
</blockquote>
<p>但是，cout 的线程安全，只能保证每一次 <code>operator&lt;&lt;</code> 都是原子的，每一次单独的 <code>operator&lt;&lt;</code> 不会被其他人打断。</p>
<p>但众所周知，cout 为了支持级联调用，他的 <code>operator&lt;&lt;</code> 都是返回自己的，上面的代码实际上等价于分别三次调用 <code>cout</code> 的 <code>operator&lt;&lt;</code>。</p>
<pre><code class="language-cpp">cout &lt;&lt; &quot;the answer is &quot; &lt;&lt; 42 &lt;&lt; '\n';
// 等价于：
cout &lt;&lt; &quot;the answer is &quot;;
cout &lt;&lt; 42;
cout &lt;&lt; '\n';
</code></pre>
<p>变成了三次 <code>operator&lt;&lt;</code>，每一次都是“各自”原子的，但三个原子加在一起就不是原子了。</p>
<blockquote>
<p><img src="../img/awesomeface.png" height="30px" width="auto" style="margin: 0; border: none"/> 而是分子了 :)</p>
</blockquote>
<p>他们中间可能穿插了其他线程的 cout，从而导致你 <code>"the answer is"</code> 打印完后，被其他线程的 <code>'\n'</code> 插入进来，导致换行混乱。</p>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> 更多细节请看我们的 <a href="../threading/">多线程专题</a>。</p>
</blockquote>
<p>解决方法是，先创建一个只属于当前线程的 <code>ostringstream</code>，最后一次性调用一次 cout 的 <code>operator&lt;&lt;</code>，让“原子”的单位变成“一行”而不是一个字符串。</p>
<pre><code class="language-cpp">ostringstream oss;
oss &lt;&lt; &quot;the answer is &quot; &lt;&lt; 42 &lt;&lt; '\n';
cout &lt;&lt; oss.str();
</code></pre>
<p>或者，使用 <code>std::format</code>：</p>
<pre><code class="language-cpp">cout &lt;&lt; std::format(&quot;the answer is {}\n&quot;, 42);
</code></pre>
<p>总之，就是要让 <code>operator&lt;&lt;</code> 只有一次。</p>
<p>建议各位升级到 C++23，然后改用 <code>std::println</code> 吧：</p>
<pre><code class="language-cpp">std::println(&quot;the answer is {}&quot;, 42);
</code></pre>
<h2 id="map-any">map + any 外挂属性</h2>
<p>TODO</p>
<h2 id="bind-lambda">bind 是历史糟粕，应该由 Lambda 表达式取代</h2>
<h2 id="forward-fwd">forward 迷惑性地不好用，建议改用 FWD 宏</h2>
<h2 id="auto">函数参数也可以 auto</h2>
<p>大家都知道，函数的返回类型可以声明为 <code>auto</code>，让其自动推导。</p>
<pre><code class="language-cpp">auto func() {  // int func();
    return 1;
}
</code></pre>
<p>但你知道从 C++20 开始，参数也可以声明为 auto 了吗？</p>
<h2 id="_6">智能指针防止大对象移动</h2>
<p>我们说一个类型大，有两种情况。</p>
<ol>
<li>类本身很大：例如 array</li>
<li>类本身不大，但其指向的对象大，且该类是深拷贝，对该类的拷贝会引起其指向对象的拷贝：例如 vector</li>
</ol>
<pre><code class="language-cpp">sizeof(array&lt;int, 1000&gt;);  // 本身 4000 字节
sizeof(vector&lt;int&gt;);       // 本身 24 字节（成员是 3 个指针），指向的数组可以无限增大
</code></pre>
<blockquote>
<p><img src="../img/question.png" height="30px" width="auto" style="margin: 0; border: none"/> <code>sizeof(vector)</code> 为 24 字节仅为 <code>x86_64-pc-linux-gnu</code> 平台 <code>libstdc++</code> 库的实测结果，在 32 位系统以及 MSVC 的 Debug 模式 STL 下可能得出不同的结果，不可以依赖这个平台相关的结果来编程。</p>
</blockquote>
<p>对于 vector，我们可以使用 <code>std::move</code> 移动语义，只拷贝该类本身的三个指针成员，而不对其指向的 4000 字节数组进行深拷贝。</p>
<p>对于 array，则 <code>std::move</code> 移动语义与普通的拷贝没有区别：array 作为静态数组容器，不是通过“指针成员”来保存数组的，而是直接把数组存在他的体内，对 array 的移动和拷贝是完全一样的！</p>
<p>总之，移动语义的加速效果，只对采用了“指针间接存储动态数据”的类型（如 vector、map、set、string）有效。对“直接存储静态大小数据”的类型（array、tuple、variant、成功“小字符串优化”的 string）无效。</p>
<p>所以，让很多“移动语义”孝子失望了：“本身很大”的类，移动和拷贝一样慢！</p>
<p>那么现在我们有个超大的类：</p>
<pre><code class="language-cpp">using BigType = array&lt;int, 1000&gt;;  // 4000 字节大小的平坦类型

vector&lt;BigType&gt; arr;

void func(BigType x) {
    arr.push_back(std::move(x));  // 拷贝 4000 字节，超慢，move 也没用
}

int main() {
    BigType x;
    func(std::move(x));  // 拷贝 4000 字节，超慢，move 也没用
}
</code></pre>
<p>如何加速这种本身超大的变量转移？使用 <code>const</code> 引用：</p>
<pre><code class="language-cpp">void func(BigType const &amp;x)
</code></pre>
<p>似乎可以避免传参时的拷贝，但是依然不能避免 <code>push_back</code> 推入 <code>vector</code> 时所不得已的拷贝。</p>
<p>小技巧：改用 <code>unique_ptr&lt;BigType&gt;</code></p>
<pre><code class="language-cpp">using BigType = array&lt;int, 1000&gt;;  // 4000 字节大小的平坦类型

using BigTypePtr = unique_ptr&lt;BigType&gt;;

vector&lt;BigType&gt; arr;

void func(BigTypePtr x) {
    arr.push_back(std::move(x));  // 只拷贝 8 字节的指针，其指向的 4000 字节不用深拷贝了，直接移动所有权给 vector 里的 BigTypePtr 智能指针
    // 由于移走了所有权，x 此时已经为 nullptr
}

int main() {
    BigTypePtr x = make_unique&lt;BigType&gt;();  // 注意：用智能指针的话，需要用 make_unique 才能创建对象了
    func(std::move(x));  // 只拷贝 8 字节的指针
    // 由于移走了所有权，x 此时已经为 nullptr
}
</code></pre>
<p>上面整个程序中，一开始通过 <code>make_unique</code> 创建的超大对象，全程没有发生任何移动，避免了无谓的深拷贝。</p>
<p>对于不支持移动构造函数的类型来说，也可以用这个方法，就能在函数之间穿梭自如了。</p>
<pre><code class="language-cpp">// 热知识：std::mutex 不支持移动

void func(std::mutex lock);

int main() {
    std::mutex lock;
    func(std::move(lock));  // 错误：mutex(mutex &amp;&amp;) = delete
}
</code></pre>
<pre><code class="language-cpp">void func(std::unique_ptr&lt;std::mutex&gt; lock);

int main() {
    std::unique_ptr&lt;std::mutex&gt; lock = std::make_unique&lt;std::mutex&gt;();
    func(std::move(lock));  // OK：调用的是 unique_ptr(unique_ptr &amp;&amp;)，不关 mutex 什么事
}
</code></pre>
<p>更好的是 <code>shared_ptr</code>，连 <code>std::move</code> 都不用写，更省心。</p>
<pre><code class="language-cpp">void func(std::shared_ptr&lt;std::mutex&gt; lock);

int main() {
    std::shared_ptr&lt;std::mutex&gt; lock = std::make_shared&lt;std::mutex&gt;();
    func(lock);  // OK：调用的是 shared_ptr(shared_ptr const &amp;)，不关 mutex 什么事
    func(lock);  // OK：shared_ptr 的拷贝构造函数是浅拷贝，即使浅拷贝发生多次，指向的对象也不会被拷贝或移动
}
</code></pre>
<h2 id="optional">optional 实现延迟初始化</h2>
<p>假设我们有一个类，具有自定义的构造函数，且没有默认构造函数：</p>
<pre><code class="language-cpp">struct SomeClass {
    int m_i;
    int m_j;

    SomeClass(int i, int j) : m_i(i), m_j(j) {}
};
</code></pre>
<p>当我们需要“延迟初始化”时怎么办？</p>
<pre><code class="language-cpp">SomeClass c;
if (test()) {
    c = SomeClass(1, 2);
} else {
    c = SomeClass(2, 3);
}
do_something(c);
</code></pre>
<p>可以利用 optional 默认初始化为“空”的特性，实现延迟赋值：</p>
<pre><code class="language-cpp">std::optional&lt;SomeClass&gt; c;
if (test()) {
    c = SomeClass(1, 2);
} else {
    c = SomeClass(2, 3);
}
do_something(c.value());  // 如果抵达此处前，c 没有初始化，就会报错，从而把编译期的未初始化转换为运行时异常
</code></pre>
<blockquote>
<p><img src="../img/book.png" height="30px" width="auto" style="margin: 0; border: none"/> 就类似于 Python 中先给变量赋值为 None，然后在循环或 if 里条件性地赋值一样。</p>
</blockquote>
<p>如果要进一步避免 <code>c =</code> 时，移动构造的开销，也可以用 <code>unique_ptr</code> 或 <code>shared_ptr</code>：</p>
<pre><code class="language-cpp">std::shared_ptr&lt;SomeClass&gt; c;
if (test()) {
    c = std::make_shared&lt;SomeClass&gt;(1, 2);
} else {
    c = std::make_shared&lt;SomeClass&gt;(2, 3);
}
do_something(c);  // 如果抵达此处前，c 没有初始化，那么传入的就是一个 nullptr，do_something 内部需要负责检测指针是否为 nullptr
</code></pre>
<p>如果 <code>do_something</code> 参数需要的是原始指针，可以用 <code>.get()</code> 获取出来：</p>
<pre><code class="language-cpp">do_something(c.get());  // .get() 可以把智能指针转换回原始指针，但请注意原始指针不持有引用，不会延伸指向对象的生命周期
</code></pre>
<blockquote>
<p><img src="../img/book.png" height="30px" width="auto" style="margin: 0; border: none"/> 实际上，Java、Python 中的一切对象（除 int、str 等“钦定”的基础类型外）都是引用计数的智能指针 <code>shared_ptr</code>，只不过因为一切皆指针了，所以看起来好像没有指针了。</p>
</blockquote>
<h2 id="if-auto-while-auto">if-auto 与 while-auto</h2>
<p>需要先定义一个变量，然后判断某些条件的情况，非常常见：</p>
<pre><code class="language-cpp">extern std::optional&lt;int&gt; some_func();

auto opt = some_func();
if (opt.has_value()) {
    std::cout &lt;&lt; opt.value();
}
</code></pre>
<p>C++17 引入的 if-auto 语法，可以就地书写变量定义和判断条件：</p>
<pre><code class="language-cpp">extern std::optional&lt;int&gt; some_func();

if (auto opt = some_func(); opt.has_value()) {
    std::cout &lt;&lt; opt.value();
}
</code></pre>
<p>对于支持 <code>(bool)opt</code> 的 <code>optional</code> 类型来说，后面的条件也可以省略：</p>
<pre><code class="language-cpp">extern std::optional&lt;int&gt; some_func();

if (auto opt = some_func()) {
    std::cout &lt;&lt; opt.value();
}

// 等价于：
auto opt = some_func();
if (opt) {
    std::cout &lt;&lt; opt.value();
}
</code></pre>
<p>类似的还有 while-auto：</p>
<pre><code class="language-cpp">extern std::optional&lt;int&gt; some_func();

while (auto opt = some_func()) {
    std::cout &lt;&lt; opt.value();
}

// 等价于：
while (true) {
    auto opt = some_func();
    if (!opt) break;
    std::cout &lt;&lt; opt.value();
}
</code></pre>
<p>if-auto 最常见的配合莫过于 map.find：</p>
<pre><code class="language-cpp">std::map&lt;int, int&gt; table;

int key = 42;
if (auto it = table.find(key); it != table.end()) {
    std::cout &lt;&lt; it-&gt;second &lt;&lt; '\n';
} else {
    std::cout &lt;&lt; &quot;not found\n&quot;;
}
</code></pre>
<h2 id="_7">检测是否存在指定成员函数</h2>
<p>TODO</p>
<h2 id="bit-field">位域（bit-field）</h2>
<h2 id="vector-unordered_map-lru-cache">vector + unordered_map = LRU cache</h2>
<h2 id="_8">多线程通信应基于队列，而不是共享全局变量</h2>
<h2 id="shared_ptr-deleter">自定义 shared_ptr 的 deleter</h2>
<h2 id="_9">读取整个文件</h2>
<h2 id="raii-finally">RAII 的 finally</h2>
<h2 id="swap-mutex">swap 缩小 mutex 区间代价</h2>
<h2 id="lambda-unique_ptr-function">Lambda 捕获 unique_ptr 导致 function 报错怎么办</h2>
<h2 id="check_cuda">CHECK_CUDA 类错误检测宏</h2>
<h2 id="_10">函数默认参数求值的位置是调用者</h2>
<h2 id="locale-utf8">设置 locale 为 .utf8</h2>
<h2 id="_11">花括号实现安全的类型转换检查</h2>
<h2 id="this">成员函数针对 this 的移动重载</h2>
<h2 id="bit-field_1">位域（bit-field）</h2>
<h2 id="vector-unordered_map-lru-cache_1">vector + unordered_map = LRU cache</h2>
<h2 id="_12">多线程通信应基于队列，而不是共享全局变量</h2>
<h2 id="shared_ptr-deleter_1">自定义 shared_ptr 的 deleter</h2>
<h2 id="_13">读取整个文件到字符串</h2>
<h2 id="raii-finally_1">RAII 的 finally</h2>
<h2 id="swap-mutex_1">swap 缩小 mutex 区间代价</h2>
<h2 id="lambda-unique_ptr-function_1">Lambda 捕获 unique_ptr 导致 function 报错怎么办</h2>
<h2 id="check_cuda_1">CHECK_CUDA 类错误检测宏</h2>
<h2 id="_14">函数默认参数求值的位置是调用者</h2>
<h2 id="locale-utf8_1">设置 locale 为 .utf8</h2>
<h2 id="_15">花括号实现安全的类型转换检查</h2>
<h2 id="this_1">成员函数针对 this 的移动重载</h2>
<h2 id="_16">临时右值转左值</h2>
<p>C++ 有个特性：支持纯右值(prvalue)隐式转换成 const 的左值引用。</p>
<p>翻译：<code>int &amp;&amp;</code> 可以自动转换成 <code>int const &amp;</code>。</p>
<pre><code class="language-cpp">void func(int const &amp;i);

func(1);  // OK：自动创建一个变量保存 1，然后作为 int const &amp; 参数传入
</code></pre>
<p>实际上就等价于：</p>
<pre><code class="language-cpp">const int tmp = 1;
func(tmp);
</code></pre>
<p>但是，<code>int &amp;&amp;</code> 却不能自动转换成 <code>int &amp;</code>。</p>
<pre><code class="language-cpp">void func(int &amp;i);

func(1);  // 错误：无法从 int &amp;&amp; 自动转换成 int &amp;
</code></pre>
<blockquote>
<p><img src="../img/bulb.png" height="30px" width="auto" style="margin: 0; border: none"/> C++ 官方设置这个限制，是出于语义安全性考虑，因为参数接受 <code>int &amp;</code> 的，一般都意味着这个是用作返回值，而如果 <code>func</code> 的参数是，<code>func(1)</code>。</p>
</blockquote>
<p>为了绕开这个规则，我们可以定义一个帮手函数：</p>
<pre><code class="language-cpp">T &amp;temporary(T const &amp;t) {
    return const_cast&lt;T &amp;&gt;(t);
}

// 或者：
T &amp;temporary(T &amp;&amp;t) {
    return const_cast&lt;T &amp;&gt;(t);
}
</code></pre>
<p>然后，就可以快乐地转换纯右值为非 const 左值了：</p>
<pre><code class="language-cpp">void func(int &amp;i);

func(temporary(1));
</code></pre>
<p>在 Libreoffice 源码中就有应用。</p>
<h2 id="_17">临时变量的生命周期是一行</h2>
<p>TODO</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>小彭老师倾 ♥ 制作</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../js/print-site.js"></script>
        <script src="../extra.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
